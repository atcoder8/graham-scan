{"version":3,"file":"js/main.bundle.js","mappings":"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","sources":["webpack://graham-scan/./src/index.ts"],"sourcesContent":["const WIDTH = 100;\nconst HEIGHT = 100;\n\nconst CANVAS_WIDTH = 640;\nconst CANVAS_HEIGHT = 640;\nconst CANVAS_PADDING = 5;\nconst CANVAS_COLOR = \"rgb(180, 235, 250)\";\n\nconst grahamScanCanvas = <HTMLCanvasElement>document.getElementById(\"graham-scan-canvas\");\nconst grahamScanCtx = grahamScanCanvas.getContext(\"2d\");\n\nconst resetButton = <HTMLButtonElement>document.getElementById(\"reset-button\");\n\nconst messageLabel = <HTMLLabelElement>document.getElementById(\"message-label\");\n\n/** This class represents two-dimensional coordinates. */\nclass Coord2D {\n    /** x-coordinate */\n    x: number;\n\n    /** y-coordinate */\n    y: number;\n\n    /**\n     * Returns whether the coordinates represented by `this` and `other` are equal or not.\n     * @param other The other coordinate.\n     * @returns Returns `true` if `this` and `other` are equal, `false` if they are different.\n     */\n    same(other: Coord2D): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    /** Converts from coordinates on the coordinate plane to coordinates on the canvas. */\n    toCanvasCoord(): Coord2D {\n        const scaleX = (CANVAS_WIDTH - 2 * CANVAS_PADDING) / WIDTH;\n        const scaleY = (CANVAS_HEIGHT - 2 * CANVAS_PADDING) / HEIGHT;\n\n        const canvasX = (this.x + 0.5) * scaleX + CANVAS_PADDING;\n        const canvasY = (this.y + 0.5) * scaleY + CANVAS_PADDING;\n\n        return new Coord2D(canvasX, canvasY);\n    }\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n// /** Returns a uniform random integer between `min` and `max`. */\n// function getRandomInt(min: number, max: number): number {\n//     return Math.floor(Math.random() * (max - min)) + min;\n// }\n\n/**\n * Fills the entire canvas with the `CANVAS_COLOR`.\n */\nfunction resetCanvas(): void {\n    grahamScanCtx.fillStyle = CANVAS_COLOR;\n    grahamScanCtx.fillRect(0, 0, CANVAS_HEIGHT, CANVAS_WIDTH);\n}\n\n/**\n * Draws a point on the coordinate plane on the canvas.\n * @param coord Coordinate of the point.\n * @param radius Radius of the point drawn on the canvas.\n * @param fillStyle Fill style of the point drawn on the canvas.\n */\nfunction drawPoint(coord: Coord2D, radius: number = 5, fillStyle: string = \"black\"): void {\n    const canvasCoord = coord.toCanvasCoord();\n\n    grahamScanCtx.fillStyle = fillStyle;\n    grahamScanCtx.beginPath();\n    grahamScanCtx.arc(canvasCoord.x, canvasCoord.y, radius, 0, 2 * Math.PI);\n    grahamScanCtx.fill();\n}\n\n/**\n * Draws some points on the coordinate plane on the canvas.\n * @param coords Array of coordinates of the point.\n * @param radius Radius of the points drawn on the canvas.\n * @param fillStyle Fill style of the points drawn on the canvas.\n */\nfunction drawPoints(coords: Coord2D[], radius: number = 5, fillStyle: string = \"black\"): void {\n    coords.forEach(coord => {\n        drawPoint(coord, radius, fillStyle);\n    });\n}\n\n/**\n * Draws a line segment on the coordinate plane on the canvas.\n * @param coord1 Coordinates of the first endpoint.\n * @param coord2 Coordinates of the second endpoint.\n */\nfunction drawLine(coord1: Coord2D, coord2: Coord2D): void {\n    let canvasCoord1 = coord1.toCanvasCoord();\n    let canvasCoord2 = coord2.toCanvasCoord();\n\n    grahamScanCtx.strokeStyle = \"black\";\n    grahamScanCtx.beginPath();\n    grahamScanCtx.moveTo(canvasCoord1.x, canvasCoord1.y);\n    grahamScanCtx.lineTo(canvasCoord2.x, canvasCoord2.y);\n    grahamScanCtx.stroke();\n}\n\n/**\n * Compares the angles of two line segments.\n * @param base1 Coordinates of the base point of the first line segment.\n * @param coord1 Coordinates of the other point of the first line segment.\n * @param base2 Coordinates of the base point of the second line segment.\n * @param coord2 Coordinates of the other point of the second line segment.\n * @returns\n * Returns `-1` if the angle of the first line segment is less than the angle of the second line segment,\n * `1` if it is greater, and `0` if it is equal.\n */\nfunction compareAngle(base1: Coord2D, coord1: Coord2D, base2: Coord2D, coord2: Coord2D): number {\n    const REGIONS = [[0, 0], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\n\n    const x1 = coord1.x - base1.x;\n    const y1 = coord1.y - base1.y;\n\n    const x2 = coord2.x - base2.x;\n    const y2 = coord2.y - base2.y;\n\n    let regionIdx1 = REGIONS.findIndex(region => region[0] === Math.sign(x1) && region[1] === Math.sign(y1));\n    let regionIdx2 = REGIONS.findIndex(region => region[0] === Math.sign(x2) && region[1] === Math.sign(y2));\n\n    if (regionIdx1 != regionIdx2) {\n        return Math.sign(regionIdx1 - regionIdx2);\n    }\n\n    return Math.sign(y1 * x2 - y2 * x1);\n}\n\n/**\n * Creates a array of coordinates included in the convex hull.\n * @param coords Array of coordinates of the point.\n * @returns Array of coordinates included in the convex hull.\n */\nfunction findConvexHull(coords: Coord2D[]): Coord2D[] {\n    if (coords.length === 0) {\n        return [];\n    }\n\n    const baseCoord = coords.reduce((provBaseCoord, candCoord) => {\n        if (candCoord.y < provBaseCoord.y || candCoord.y === provBaseCoord.y && candCoord.x < provBaseCoord.x) {\n            return candCoord;\n        }\n\n        return provBaseCoord;\n    });\n\n    let sortedCoords = [...coords];\n    sortedCoords.sort((coord1, coord2) => compareAngle(baseCoord, coord1, baseCoord, coord2));\n\n    let convexHull = Array.from([baseCoord]);\n    for (const coord of sortedCoords) {\n        if (coord.same(convexHull[convexHull.length - 1])) {\n            continue;\n        }\n\n        while (convexHull.length >= 2) {\n            if (compareAngle(convexHull[convexHull.length - 1], coord, convexHull[convexHull.length - 2], coord) <= 0) {\n                convexHull.pop();\n            } else {\n                break;\n            }\n        }\n\n        convexHull.push(coord);\n    }\n\n    return convexHull;\n}\n\n/**\n * Calculates the convex hull from points in the coordinate plane and draws it on the canvas.\n * @param coords Array of coordinates of the point.\n */\nfunction drawConvexHull(coords: Coord2D[]) {\n    let convexHull = findConvexHull(coords);\n\n    resetCanvas();\n\n    drawPoints(coords);\n\n    grahamScanCtx.strokeStyle = \"black\";\n\n    drawPoints(convexHull, 5, \"red\");\n\n    for (let i = 0; i < convexHull.length - 1; i++) {\n        drawLine(convexHull[i], convexHull[i + 1]);\n    }\n\n    if (convexHull.length >= 3) {\n        drawLine(convexHull[convexHull.length - 1], convexHull[0]);\n    }\n\n    let percentageMessage = \"\";\n    if (coords.length !== 0) {\n        let percentage = 100 * convexHull.length / coords.length;\n        percentageMessage = \" (\" + percentage.toPrecision(3) + \"%)\";\n    }\n\n    messageLabel.textContent = \"Included in the convex hull: \" + convexHull.length + \" / \" + points.length + percentageMessage;\n}\n\n/** Array of points on the coordinate plane. */\nlet points: Coord2D[] = Array();\n\ngrahamScanCanvas.addEventListener(\"click\", event => {\n    const boundingRect = grahamScanCanvas.getBoundingClientRect();\n\n    const scaleX = grahamScanCanvas.width / boundingRect.width;\n    const scaleY = grahamScanCanvas.height / boundingRect.height;\n\n    const canvasX = (event.clientX - boundingRect.left) * scaleX;\n    const canvasY = (event.clientY - boundingRect.top) * scaleY;\n\n    if (canvasX < CANVAS_PADDING || canvasX >= CANVAS_PADDING + CANVAS_WIDTH\n        || canvasY < CANVAS_PADDING || canvasY >= CANVAS_PADDING + CANVAS_HEIGHT) {\n        return;\n    }\n\n    const clickedX = Math.min(Math.floor((canvasX - CANVAS_PADDING) / ((CANVAS_WIDTH - 2 * CANVAS_PADDING) / WIDTH)), WIDTH - 1);\n    const clickedY = Math.min(Math.floor((canvasY - CANVAS_PADDING) / ((CANVAS_HEIGHT - 2 * CANVAS_PADDING) / HEIGHT)), HEIGHT - 1);\n    const clickedCoord = new Coord2D(clickedX, clickedY);\n\n    let idx = points.findIndex(coord => coord.same(clickedCoord));\n    if (idx === -1) {\n        points.push(new Coord2D(clickedX, clickedY));\n    } else {\n        points.splice(idx, 1);\n    }\n\n    drawConvexHull(points);\n});\n\nresetButton.addEventListener(\"click\", _event => {\n    points = [];\n    drawConvexHull(points);\n});\n\ngrahamScanCanvas.width = CANVAS_WIDTH;\ngrahamScanCanvas.height = CANVAS_HEIGHT;\n\ndrawConvexHull(points);\n"],"names":[],"sourceRoot":""}